<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combined Gene Expression and Cell Boundary Viewer</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Load configuration first -->
    <script src="config.js"></script>
    <script src="https://unpkg.com/deck.gl@8.8.27/dist.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-dsv@3"></script>
    <script src="https://unpkg.com/d3-array@3"></script>
    <!-- Import the polygon boundary highlighter -->
    <script src="modules/polygon-boundary-highlighter.js"></script>
    <!-- Import glyph helpers -->
    <script src="modules/glyphPaths.js"></script>
    <script src="modules/glyphConfig.js"></script>
</head>
<body>
    <div id="map"></div>
    <div id="tooltip"></div>

    <!-- Gene Panel Button -->
    <button id="genePanelBtn">Gene Panel</button>

    <!-- Main Controls -->
    <div class="main-controls">
        <button class="nav-btn" id="prevBtn">â—„</button>
        <input type="range" id="planeSlider" min="0" max="99" value="50">
        <button class="nav-btn" id="nextBtn">â–º</button>
        <span id="planeLabel">Plane: 50</span>
    </div>

    <!-- Layer Controls -->
    <div class="layer-controls" id="layerControls">
        <button class="minimize-btn" id="minimizeBtn">âˆ’</button>
        <h3>Display Layers</h3>

        <div class="control-section">
            <h4>Main Layers</h4>
            <div class="layer-toggle">
                <input type="checkbox" id="showTiles" checked>
                <label for="showTiles">Background Images</label>
            </div>
            <div class="layer-toggle">
                <input type="checkbox" id="showPolygons" checked>
                <label for="showPolygons">Cell Boundaries</label>
            </div>
            <div class="layer-toggle">
                <input type="checkbox" id="showGenes" checked>
                <label for="showGenes">Gene Expression</label>
            </div>
        </div>

        <div class="control-section">
            <h4>Polygon Groups</h4>
            <button class="toggle-btn secondary" id="toggleAllPolygons">Toggle All Groups</button>
            <div id="polygonAliasControls">
                <!-- Dynamically populated -->
            </div>
        </div>

        <div class="control-section gene-controls">
            <h4>Gene Display</h4>
            <div class="gene-size-control">
                <label for="geneSizeSlider">Gene Size: <span id="geneSizeValue">1.0</span></label>
                <input type="range" id="geneSizeSlider" min="0.5" max="3.0" step="0.1" value="1.0">
            </div>
            <button class="toggle-btn secondary" id="toggleAllGenes">Toggle All Genes</button>
        </div>
    </div>

    <div class="loading-indicator" id="loadingIndicator">Loading...</div>

    <script type="module">
        // Import configuration constants
        import {
            INITIAL_VIEW_STATE,
            MAX_PRELOAD,
            DEFAULT_STATE,
            UI_ELEMENTS
        } from './config/constants.js';

        // Import coordinate transformation utilities
        import {
            clamp
        } from './utils/coordinateTransform.js';

        // Import data loading functions
        import {
            loadGeneData,
            loadPolygonData,
            assignColorsToPolygonAliases
        } from './modules/dataLoaders.js';

        // Import layer creation functions
        import {
            createTileLayer,
            createPolygonLayers,
            createGeneLayers
        } from './modules/layerCreators.js';

        // Import UI helper functions
        import {
            showLoading,
            hideLoading,
            showTooltip,
            updatePolygonAliasControls
        } from './modules/uiHelpers.js';

        // Import event handling functions
        import {
            setupEventHandlers
        } from './modules/eventHandlers.js';

        // Extract deck.gl components
        const {DeckGL, OrthographicView, COORDINATE_SYSTEM} = deck;

        // Application state
        const state = {
            currentPlane: DEFAULT_STATE.currentPlane,
            deckglInstance: null,
            isLoading: false,
            
            // Layer visibility
            showTiles: DEFAULT_STATE.showTiles,
            showPolygons: DEFAULT_STATE.showPolygons,
            showGenes: DEFAULT_STATE.showGenes,
            
            // Data caches
            tileCache: new Map(),
            polygonCache: new Map(),
            geneDataMap: new Map(),
            
            // Layer persistence for better performance
            tileLayers: new Map(), // Cache tile layer instances
            
            // Performance tracking
            polygonLoadTimes: new Map(),
            lastCleanupTime: Date.now(),
            
            // Polygon data
            polygonAliasVisibility: new Map(),
            polygonAliasColors: new Map(),
            allPolygonAliases: new Set(),
            
            // Gene data
            selectedGenes: new Set(),
            geneIconAtlas: null,
            geneIconMapping: null,
            geneSizeScale: DEFAULT_STATE.geneSizeScale,
            
            // Interactions
            polygonHighlighter: null,
            genePanelWin: null
        };

        // DOM elements
        const elements = {
            slider: document.getElementById(UI_ELEMENTS.planeSlider),
            label: document.getElementById(UI_ELEMENTS.planeLabel),
            prevBtn: document.getElementById(UI_ELEMENTS.prevBtn),
            nextBtn: document.getElementById(UI_ELEMENTS.nextBtn),
            loadingIndicator: document.getElementById(UI_ELEMENTS.loadingIndicator),
            
            // Layer controls
            showTiles: document.getElementById(UI_ELEMENTS.showTiles),
            showPolygons: document.getElementById(UI_ELEMENTS.showPolygons),
            showGenes: document.getElementById(UI_ELEMENTS.showGenes),
            
            // Polygon controls
            toggleAllPolygons: document.getElementById(UI_ELEMENTS.toggleAllPolygons),
            polygonAliasControls: document.getElementById(UI_ELEMENTS.polygonAliasControls),
            
            // Gene controls
            geneSizeSlider: document.getElementById(UI_ELEMENTS.geneSizeSlider),
            geneSizeValue: document.getElementById(UI_ELEMENTS.geneSizeValue),
            toggleAllGenes: document.getElementById(UI_ELEMENTS.toggleAllGenes),
            genePanelBtn: document.getElementById(UI_ELEMENTS.genePanelBtn),
            
            // UI
            layerControls: document.getElementById(UI_ELEMENTS.layerControls),
            minimizeBtn: document.getElementById(UI_ELEMENTS.minimizeBtn),
            tooltip: document.getElementById(UI_ELEMENTS.tooltip)
        };

        // === UTILITY FUNCTIONS ===
        // Utility functions have been moved to modules/uiHelpers.js and modules/dataLoaders.js


        // === GENE DATA FUNCTIONS ===
        // Gene data loading functions have been moved to modules/dataLoaders.js

        // === POLYGON DATA FUNCTIONS ===
        // Polygon data loading functions have been moved to modules/dataLoaders.js

        // === LAYER CREATION FUNCTIONS ===
        // Layer creation functions have been moved to modules/layerCreators.js

        // === MAIN UPDATE FUNCTION ===
        function updateAllLayers() {
            if (!state.deckglInstance) return;

            const layers = [];

            // Add tile layers - keep same instances, only change opacity
            const direction = elements.slider.value > state.currentPlane ? 1 : -1;
            const preloadAhead = direction === 1 ? MAX_PRELOAD + 1 : MAX_PRELOAD;
            const preloadBehind = direction === -1 ? MAX_PRELOAD + 1 : MAX_PRELOAD;

            const userConfig = window.config();
            const start = Math.max(0, state.currentPlane - preloadBehind);
            const end = Math.min(userConfig.totalPlanes - 1, state.currentPlane + preloadAhead);

            for (let plane = start; plane <= end; plane++) {
                const opacity = plane === state.currentPlane ? 1 : 0;
                const layerId = `tiles-${plane}`;
                
                // Reuse existing layer instance or create new one
                let tileLayer = state.tileLayers.get(layerId);
                if (!tileLayer) {
                    tileLayer = createTileLayer(plane, opacity, state.tileCache, state.showTiles);
                    state.tileLayers.set(layerId, tileLayer);
                } else {
                    // Update existing layer's opacity and visibility
                    tileLayer = tileLayer.clone({
                        opacity: opacity,
                        visible: state.showTiles
                    });
                    state.tileLayers.set(layerId, tileLayer);
                }
                
                layers.push(tileLayer);
            }

            // Add polygon layers for current plane ONLY if cached
            if (state.polygonCache.has(state.currentPlane)) {
                layers.push(...createPolygonLayers(state.currentPlane, state.polygonCache, state.showPolygons, state.polygonAliasVisibility, state.polygonAliasColors));
            }

            // Add gene layers
            layers.push(...createGeneLayers(state.geneDataMap, state.showGenes, state.selectedGenes, state.geneIconAtlas, state.geneIconMapping, state.currentPlane, state.geneSizeScale, (info) => showTooltip(info, elements.tooltip)));

            state.deckglInstance.setProps({ layers: layers });
        }

        // === PERFORMANCE-OPTIMIZED PLANE UPDATE ===
        
        // Fast update for immediate visual feedback (tiles and genes only)
        function updatePlaneImmediate(newPlane) {
            const perfStart = performance.now();
            
            const userConfig = window.config();
            const clampedPlane = clamp(newPlane, 0, userConfig.totalPlanes - 1);
            
            // Update UI immediately - no async operations
            state.currentPlane = clampedPlane;
            elements.slider.value = state.currentPlane;
            elements.label.textContent = `Plane: ${state.currentPlane}`;
            
            // Update layers immediately (tiles + genes always work, polygons use cached data if available)
            updateAllLayers();
            
            const perfTime = performance.now() - perfStart;
            if (userConfig.showPerformanceStats) {
                console.log(`âš¡ Immediate plane update: ${perfTime.toFixed(1)}ms`);
            }
        }
        
        // Background polygon loading - doesn't block UI
        async function updatePlanePolygonsAsync(planeNum) {
            const startTime = performance.now();
            
            // Skip if already cached - major performance boost
            if (state.polygonCache.has(planeNum)) {
                console.log(`Plane ${planeNum} polygons already cached - skipping load`);
                return;
            }
            
            try {
                // Show loading only for longer operations
                const loadingTimeout = setTimeout(() => {
                    if (state.currentPlane === planeNum) { // Only show if still current
                        showLoading(state, elements.loadingIndicator);
                    }
                }, 50); // Show loading after 50ms delay
                
                console.log(`Background loading polygon data for plane ${planeNum}`);
                await loadPolygonData(planeNum, state.polygonCache, state.allPolygonAliases);
                
                clearTimeout(loadingTimeout);
                hideLoading(state, elements.loadingIndicator);
                
                const loadTime = performance.now() - startTime;
                console.log(`Loaded plane ${planeNum} polygons in ${loadTime.toFixed(1)}ms`);
                
                // Only update UI if this is still the current plane (user might have moved on)
                if (state.currentPlane === planeNum) {
                    // Check if we actually got new polygon groups
                    const prevGroupCount = state.polygonAliasColors.size;
                    assignColorsToPolygonAliases(state.allPolygonAliases, state.polygonAliasColors, state.polygonAliasVisibility);
                    
                    // Only rebuild UI controls if new groups were added
                    if (state.polygonAliasColors.size > prevGroupCount) {
                        console.log(`New polygon groups detected, updating controls`);
                        updatePolygonAliasControls(state.allPolygonAliases, state.polygonAliasVisibility, state.polygonAliasColors, elements.polygonAliasControls, updateAllLayers);
                    }
                    
                    // Refresh layers to show new polygon data (only if still current plane)
                    updateAllLayers();
                }
                
                // Background preloading of adjacent planes
                requestIdleCallback(() => {
                    preloadAdjacentPlanes(planeNum);
                }, { timeout: 1000 });
                
            } catch (error) {
                clearTimeout(loadingTimeout);
                hideLoading(state, elements.loadingIndicator);
                console.error(`Failed to load polygon data for plane ${planeNum}:`, error);
            }
        }
        
        // Memory management for polygon cache
        function cleanupPolygonCache() {
            const now = Date.now();
            const maxCacheSize = 50; // Keep max 50 planes in memory
            const cleanupInterval = 30000; // Clean every 30 seconds
            
            // Skip if cleaned recently
            if (now - state.lastCleanupTime < cleanupInterval) {
                return;
            }
            
            if (state.polygonCache.size > maxCacheSize) {
                console.log(`Polygon cache has ${state.polygonCache.size} entries, cleaning up...`);
                
                // Keep current plane and adjacent planes
                const userConfig = window.config();
                const keepPlanes = new Set([
                    Math.max(0, state.currentPlane - 3),
                    Math.max(0, state.currentPlane - 2),
                    Math.max(0, state.currentPlane - 1),
                    state.currentPlane,
                    Math.min(userConfig.totalPlanes - 1, state.currentPlane + 1),
                    Math.min(userConfig.totalPlanes - 1, state.currentPlane + 2),
                    Math.min(userConfig.totalPlanes - 1, state.currentPlane + 3)
                ]);
                
                // Remove distant planes
                let removedCount = 0;
                for (const [plane] of state.polygonCache.entries()) {
                    if (!keepPlanes.has(plane)) {
                        state.polygonCache.delete(plane);
                        state.polygonLoadTimes.delete(plane);
                        removedCount++;
                    }
                }
                
                console.log(`Removed ${removedCount} planes from cache, ${state.polygonCache.size} remaining`);
                state.lastCleanupTime = now;
            }
        }
        
        // Smart preloading of adjacent planes
        function preloadAdjacentPlanes(currentPlane) {
            const userConfig = window.config();
            const planesToPreload = [];
            
            // Preload previous plane
            if (currentPlane > 0 && !state.polygonCache.has(currentPlane - 1)) {
                planesToPreload.push(currentPlane - 1);
            }
            
            // Preload next plane
            if (currentPlane < userConfig.totalPlanes - 1 && !state.polygonCache.has(currentPlane + 1)) {
                planesToPreload.push(currentPlane + 1);
            }
            
            // Clean up cache before preloading
            cleanupPolygonCache();
            
            // Load one at a time to avoid overwhelming the browser
            planesToPreload.forEach((plane, index) => {
                setTimeout(() => {
                    if (!state.polygonCache.has(plane)) { // Double-check it's still needed
                        console.log(`Preloading plane ${plane} in background`);
                        loadPolygonData(plane, state.polygonCache, state.allPolygonAliases).catch(() => {});
                    }
                }, index * 200); // Stagger requests by 200ms
            });
        }
        
        // Main update function - now lightning fast
        function updatePlane(newPlane) {
            // No loading check needed - this is now non-blocking
            
            // Step 1: Immediate visual update (5-20ms)
            updatePlaneImmediate(newPlane);
            
            // Step 2: Load polygon data for current plane + adjacent planes immediately
            const userConfig = window.config();
            const planesToLoad = [
                Math.max(0, state.currentPlane - 1),           // Previous plane
                state.currentPlane,                            // Current plane
                Math.min(userConfig.totalPlanes - 1, state.currentPlane + 1)  // Next plane
            ];
            
            // Start loading all planes in parallel
            planesToLoad.forEach(plane => {
                if (!state.polygonCache.has(plane)) {
                    updatePlanePolygonsAsync(plane);
                }
            });
        }

        // === TOOLTIP FUNCTIONS ===
        // Tooltip functions have been moved to modules/uiHelpers.js

        // === DECK.GL INITIALIZATION ===
        function initializeDeckGL() {
            state.deckglInstance = new DeckGL({
                container: 'map',
                views: [new OrthographicView({id: 'ortho'})],
                initialViewState: INITIAL_VIEW_STATE,
                controller: {
                    minZoom: 0,
                    maxZoom: 8,
                    scrollZoom: true,
                    doubleClickZoom: true,
                    touchZoom: true,
                    keyboard: true
                },
                onHover: (info) => showTooltip(info, elements.tooltip),
                getCursor: ({isHovering}) => (isHovering ? 'pointer' : 'default'),
                layers: []
            });

            // Initialize polygon highlighter
            state.polygonHighlighter = new PolygonBoundaryHighlighter(
                state.deckglInstance,
                COORDINATE_SYSTEM.CARTESIAN
            );
            state.polygonHighlighter.initialize();
        }

        // === EVENT HANDLERS ===
        // Event handling functions have been moved to modules/eventHandlers.js

        // === MAIN INITIALIZATION ===
        async function init() {
            showLoading(state, elements.loadingIndicator);
            
            const userConfig = window.config();
            
            // Performance optimization info
            if (userConfig.enablePerformanceMode) {
                console.log('ðŸš€ Performance optimizations enabled:');
                console.log('  â€¢ Two-phase updates (immediate UI + background data)');
                console.log('  â€¢ Smart caching with automatic cleanup');
                console.log('  â€¢ Background preloading of adjacent planes');
                console.log('  â€¢ Reduced slider debouncing for instant response');
                console.log('  â€¢ Memory management (max 50 planes cached)');
            }
            
            // Clear polygon cache to ensure fresh load on app restart
            state.polygonCache.clear();
            
            // Initialize deck.gl instance and create the map container
            initializeDeckGL();
            
            // Setup all UI event listeners (slider, buttons, toggles, etc.)
            setupEventHandlers(elements, state, updatePlane, updateAllLayers);
            
            // Load gene data first - this builds the gene icon atlas and populates geneDataMap
            // Gene data is shared across all planes, so we only need to load it once
            const {atlas, mapping} = await loadGeneData(state.geneDataMap, state.selectedGenes);
            state.geneIconAtlas = atlas;
            state.geneIconMapping = mapping;
            
            // CRITICAL FIX: Load polygon data for current plane + adjacent planes during initialization
            // This prevents flickering on the very first slider movement
            console.log(`Init: Loading polygon data for plane ${state.currentPlane} + adjacent planes`);
            
            // Load current plane first (blocking)
            const polygonResult = await loadPolygonData(state.currentPlane, state.polygonCache, state.allPolygonAliases);
            console.log(`Init: Current plane polygon data loaded:`, polygonResult);
            
            // Preload adjacent planes (non-blocking)
            const adjacentPlanes = [
                Math.max(0, state.currentPlane - 1),
                Math.min(userConfig.totalPlanes - 1, state.currentPlane + 1)
            ];
            
            adjacentPlanes.forEach(async (plane) => {
                if (plane !== state.currentPlane && !state.polygonCache.has(plane)) {
                    console.log(`Init: Preloading polygon data for adjacent plane ${plane}`);
                    loadPolygonData(plane, state.polygonCache, state.allPolygonAliases).catch(() => {
                        console.log(`Init: Failed to preload plane ${plane} (non-critical)`);
                    });
                }
            });
            
            // Assign colors and update controls after loading polygon data
            assignColorsToPolygonAliases(state.allPolygonAliases, state.polygonAliasColors, state.polygonAliasVisibility);
            updatePolygonAliasControls(state.allPolygonAliases, state.polygonAliasVisibility, state.polygonAliasColors, elements.polygonAliasControls, updateAllLayers);
            
            // Update UI to reflect the current plane state after data loading
            state.currentPlane = DEFAULT_STATE.currentPlane;
            elements.slider.min = 0;
            elements.slider.max = userConfig.totalPlanes - 1;
            elements.slider.value = state.currentPlane;
            elements.label.textContent = `Plane: ${state.currentPlane}`;
            
            // Now safely update all layers - all required data (genes, polygons) is loaded
            // This will render: background tiles + gene markers + cell boundary polygons
            updateAllLayers();
            
            hideLoading(state, elements.loadingIndicator);
            
            if (userConfig.showPerformanceStats) {
                console.log('âœ… Initialization complete. Slider should now be very responsive!');
            }
        }

        // Start the application
        window.addEventListener('load', init);
    </script>
</body>
</html>