<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cell Type scRNA Reference Explorer Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8fafc;
            color: #334155;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            text-align: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .controls-section {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            align-items: end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-weight: 600;
            color: #374151;
            font-size: 0.9rem;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 0.75rem 1rem;
            background: #f1f5f9;
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .file-input-label:hover {
            background: #e2e8f0;
            border-color: #94a3b8;
        }

        select, input[type="range"] {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: white;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }

        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .slider-wrapper {
            position: relative;
        }

        .slider-value {
            background: #667eea;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(3, auto);
            gap: 2rem;
        }

        @media (max-width: 1200px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }

        .chart-panel {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .chart-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .chart-panel h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #f1f5f9;
        }

        .chart {
            width: 100%;
            height: 450px;
            border-radius: 8px;
            overflow: hidden;
        }

        .status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #1f2937;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            z-index: 1000;
            transform: translateY(-100%);
            transition: transform 0.3s;
        }

        .status-bar.show {
            transform: translateY(0);
        }

        .error-message {
            background: #fef2f2;
            color: #dc2626;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #fecaca;
            margin-bottom: 1rem;
            display: none;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            font-size: 1.1rem;
            color: #6b7280;
        }

        .loading::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid #e5e7eb;
            border-top-color: #667eea;
            border-radius: 50%;
            margin-left: 1rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        

        .instructions {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
            font-size: 0.9rem;
            color: #0c4a6e;
        }

        .instructions h4 {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-dsv@3"></script>
    <script src="https://unpkg.com/d3-scale-chromatic@3"></script>
    <script src="https://unpkg.com/d3-array@3"></script>
</head>
<body>

    <div class="status-bar" id="statusBar"></div>

    <header class="header">
        <h1>scRNA Reference Explorer</h1>
        <p>Analyze single-cell reference data for spatial transcriptomics</p>
    </header>

    <div class="container">
        <div class="instructions">
            <h4>How to use:</h4>
            1. Upload a CSV file with genes as rows and cell classes as columns<br>
            2. Select two classes to compare using the dropdowns<br>
            3. Adjust the minimum expression threshold to filter low-expression genes<br>
            4. Explore the five interactive visualizations below
        </div>

        <div class="controls-section">
            <div class="controls-grid">
                <div class="control-group">
                    <label for="csvFile">Upload CSV File</label>
                    <div class="file-input-wrapper">
                        <input id="csvFile" type="file" accept=".csv,text/csv" class="file-input">
                        <label for="csvFile" class="file-input-label">
                            üìÅ Choose CSV file (genes √ó classes)
                        </label>
                    </div>
                </div>

                <div class="control-group">
                    <label for="classA">Class A</label>
                    <select id="classA">
                        <option value="">Select Class A</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="classB">Class B</label>
                    <select id="classB">
                        <option value="">Select Class B</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="minExpr">Min Expression Threshold<span class="slider-value" id="minExprVal">0.10</span></label>
                    <input id="minExpr" type="range" min="0" max="2" step="0.1" value="0.1">
                </div>
            </div>
        </div>

        <div id="error" class="error-message"></div>

        <div class="charts-grid">
            <div class="chart-panel">
                <h3>Expression Heatmap</h3>
                <div id="heatmap" class="chart">
                    <div class="loading">Loading data...</div>
                </div>
            </div>

            <div class="chart-panel">
                <h3 id="specificityTitle">Gene Specificity Analysis</h3>
                <div id="specificity" class="chart">
                    <div class="loading">Select classes to begin</div>
                </div>
            </div>

            <div class="chart-panel">
                <h3 id="pairwiseTitle">Pairwise Class Comparison</h3>
                <div id="pairwise" class="chart">
                    <div class="loading">Select classes to compare</div>
                </div>
            </div>

            <div class="chart-panel">
                <h3>Top Discriminating Genes</h3>
                <div class="chart">
                    <div class="loading">TBA - To Be Added</div>
                </div>
            </div>

            <div class="chart-panel">
                <h3>Differential Expression Analysis</h3>
                <div class="chart">
                    <div class="loading">TBA - To Be Added</div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Enhanced scRNA Explorer Dashboard
        (function() {
            const state = {
                df: null,
                genes: [],
                classes: [],
                classA: null,
                classB: null,
                minExpr: 0.1,
                symmetricAxes: true,
            };

            const elements = {
                file: document.getElementById('csvFile'),
                classA: document.getElementById('classA'),
                classB: document.getElementById('classB'),
                minExpr: document.getElementById('minExpr'),
                minExprVal: document.getElementById('minExprVal'),
                error: document.getElementById('error'),
                statusBar: document.getElementById('statusBar'),
                heatmap: document.getElementById('heatmap'),
                specificity: document.getElementById('specificity'),
                pairwise: document.getElementById('pairwise'),
                tooltip: document.getElementById('tooltip'),
                specificityTitle: document.getElementById('specificityTitle'),
                pairwiseTitle: document.getElementById('pairwiseTitle')
                // discriminators and volcano charts are hidden (TBA)
            };

            // Utility functions
            function showStatus(message, duration = 3000) {
                elements.statusBar.textContent = message;
                elements.statusBar.classList.add('show');
                if (duration > 0) {
                    setTimeout(() => {
                        elements.statusBar.classList.remove('show');
                    }, duration);
                }
            }

            function showError(message) {
                elements.error.textContent = message;
                elements.error.style.display = message ? 'block' : 'none';
            }

            function clearError() {
                showError('');
            }

            // CSV handling
            async function handleCSVText(text) {
                clearError();
                showStatus('Processing CSV data...', 0);

                try {
                    let data = d3.csvParse(text);
                    if (!data.length) {
                        throw new Error('CSV file is empty');
                    }

                    // Detect gene column
                    const cols = data.columns;
                    const geneCol = cols.find(c => c.toLowerCase() === 'gene') ||
                                   cols.find(c => c.toLowerCase().includes('unnamed')) ||
                                   cols[0];

                    // Parse numeric columns
                    const classCols = cols.filter(c => c !== geneCol);
                    if (classCols.length < 2) {
                        throw new Error('Need at least 2 class columns for analysis');
                    }

                    // Convert to numeric values
                    data.forEach(row => {
                        classCols.forEach(c => {
                            const v = +row[c];
                            row[c] = Number.isFinite(v) ? v : 0;
                        });
                    });

                    state.df = data;
                    state.genes = data.map(d => d[geneCol]);
                    state.classes = classCols;
                    state.classA = state.classes[0] || null;
                    state.classB = state.classes[1] || state.classes[0] || null;

                    populateClassDropdowns();
                    renderAllCharts();
                    showStatus(`Loaded ${state.genes.length} genes across ${state.classes.length} classes`);
                } catch (error) {
                    showError(`Error processing CSV: ${error.message}`);
                    showStatus('');
                }
            }

            function populateClassDropdowns() {
                const options = state.classes.map(c => `<option value="${c}">${c}</option>`).join('');
                elements.classA.innerHTML = '<option value="">Select Class A</option>' + options;
                elements.classB.innerHTML = '<option value="">Select Class B</option>' + options;
                elements.classA.value = state.classA || '';
                elements.classB.value = state.classB || '';
            }

            // Data analysis functions
            function computeVariancePerGene() {
                return state.df.map(row => {
                    const vals = state.classes.map(c => +row[c] || 0);
                    return d3.variance(vals) ?? 0;
                });
            }

            function specificityScores() {
                const totals = state.df.map(row => d3.sum(state.classes, c => +row[c] || 0));
                const result = new Map();

                for (const className of state.classes) {
                    const arr = new Float64Array(state.df.length);
                    for (let i = 0; i < state.df.length; i++) {
                        const classExpr = +state.df[i][className] || 0;
                        const total = totals[i] || 0;
                        arr[i] = total > 1e-10 ? classExpr / total : 0;
                    }
                    result.set(className, arr);
                }
                return result;
            }

            function discriminationScores(classA, classB, minExprThreshold) {
                const n = state.df.length;
                const arr = new Float64Array(n);

                for (let i = 0; i < n; i++) {
                    const a = Math.max(+state.df[i][classA] || 0, 0);
                    const b = Math.max(+state.df[i][classB] || 0, 0);
                    const aSafe = Math.max(a, 1e-6);
                    const bSafe = Math.max(b, 1e-6);
                    const foldChange = Math.abs(aSafe / bSafe);
                    const reliability = Math.sqrt(Math.max(Math.min(a, b), 0));
                    let score = foldChange * reliability;

                    if (a < minExprThreshold && b < minExprThreshold) {
                        score *= 0.1;
                    }
                    arr[i] = score;
                }
                return arr;
            }

            // Volcano plot analysis functions
            function calculateAUC(classAValues, classBValues) {
                // Calculate Area Under ROC Curve for biomarker identification
                const n1 = classAValues.length;
                const n2 = classBValues.length;

                if (n1 === 0 || n2 === 0) return 0.5;

                // Combine and sort all values
                const combined = [];
                classAValues.forEach(val => combined.push({ value: val, group: 'A' }));
                classBValues.forEach(val => combined.push({ value: val, group: 'B' }));
                combined.sort((a, b) => a.value - b.value);

                // Calculate AUC using Mann-Whitney U statistic
                let rank = 1;
                let rankSum = 0;

                for (let i = 0; i < combined.length; i++) {
                    if (i > 0 && combined[i].value !== combined[i-1].value) {
                        rank = i + 1;
                    }
                    if (combined[i].group === 'A') {
                        rankSum += rank;
                    }
                }

                const auc = (rankSum - n1 * (n1 + 1) / 2) / (n1 * n2);
                return Math.abs(auc - 0.5) + 0.5; // Convert to discriminative power (0.5-1.0)
            }

            function calculateWelchTTest(classAValues, classBValues) {
                // Welch's t-test for unequal variances
                const n1 = classAValues.length;
                const n2 = classBValues.length;

                if (n1 < 2 || n2 < 2) return 1.0; // Return non-significant p-value

                const mean1 = d3.mean(classAValues) || 0;
                const mean2 = d3.mean(classBValues) || 0;
                const var1 = d3.variance(classAValues) || 1e-10;
                const var2 = d3.variance(classBValues) || 1e-10;

                const pooledSE = Math.sqrt(var1/n1 + var2/n2);
                if (pooledSE === 0) return 1.0;

                const t = (mean1 - mean2) / pooledSE;

                // Approximate degrees of freedom for Welch's t-test
                const df = Math.pow(var1/n1 + var2/n2, 2) /
                          (Math.pow(var1/n1, 2)/(n1-1) + Math.pow(var2/n2, 2)/(n2-1));

                // Simple approximation for p-value (for visualization purposes)
                // In production, use proper statistical library
                const pValue = Math.min(1.0, 2 * (1 - approximateStudentTCDF(Math.abs(t), df)));
                return Math.max(1e-10, pValue); // Prevent log(0)
            }

            function approximateStudentTCDF(t, df) {
                // Simple approximation of Student's t cumulative distribution function
                // For visualization purposes only - use proper statistical library in production
                if (df >= 30) {
                    // Approximate as normal distribution for large df
                    return approximateNormalCDF(t);
                }

                // Very rough approximation for small df
                const x = t / Math.sqrt(df);
                return 0.5 + 0.5 * Math.tanh(x * 0.7);
            }

            function approximateNormalCDF(z) {
                // Approximate standard normal CDF using error function approximation
                return 0.5 * (1 + Math.sign(z) * Math.sqrt(1 - Math.exp(-2 * z * z / Math.PI)));
            }

            function volcanoAnalysis(classA, classB, minExprThreshold) {
                // Perform differential expression analysis for volcano plot
                const results = [];

                // Get all expression values for each class to calculate per-gene statistics
                const classAData = [];
                const classBData = [];

                // For this demo, we'll treat each gene's expression as coming from a population
                // In real scRNA-seq, you'd have multiple cells per class
                state.classes.forEach(className => {
                    const isClassA = className === classA;
                    const isClassB = className === classB;

                    if (isClassA || isClassB) {
                        state.df.forEach((row, geneIdx) => {
                            const expr = +row[className] || 0;
                            if (expr >= minExprThreshold) {
                                if (isClassA) {
                                    if (!classAData[geneIdx]) classAData[geneIdx] = [];
                                    classAData[geneIdx].push(expr);
                                }
                                if (isClassB) {
                                    if (!classBData[geneIdx]) classBData[geneIdx] = [];
                                    classBData[geneIdx].push(expr);
                                }
                            }
                        });
                    }
                });

                // For each gene, calculate statistics
                for (let i = 0; i < state.df.length; i++) {
                    const exprA = +state.df[i][classA] || 0;
                    const exprB = +state.df[i][classB] || 0;

                    if (exprA < minExprThreshold && exprB < minExprThreshold) continue;

                    // Calculate fold change (linear, not log2 yet)
                    const foldChange = Math.max(exprA, 1e-6) / Math.max(exprB, 1e-6);
                    const log2FC = Math.log2(foldChange);

                    // For AUC calculation, create pseudo-populations
                    // In real data, you'd have multiple cells per class
                    const genePseudoA = classAData[i] || [exprA];
                    const genePseudoB = classBData[i] || [exprB];

                    // Add some noise to create pseudo-replicates for statistical testing
                    const pseudoReplicatesA = [];
                    const pseudoReplicatesB = [];

                    for (let rep = 0; rep < 5; rep++) {
                        const noiseA = exprA * (0.9 + Math.random() * 0.2); // ¬±10% noise
                        const noiseB = exprB * (0.9 + Math.random() * 0.2);
                        pseudoReplicatesA.push(Math.max(0, noiseA));
                        pseudoReplicatesB.push(Math.max(0, noiseB));
                    }

                    // Calculate AUC for biomarker quality
                    const auc = calculateAUC(pseudoReplicatesA, pseudoReplicatesB);

                    // Calculate p-value using Welch's t-test
                    const pValue = calculateWelchTTest(pseudoReplicatesA, pseudoReplicatesB);

                    // Calculate average expression for sizing
                    const avgExpression = (exprA + exprB) / 2;

                    results.push({
                        gene: state.genes[i],
                        log2FC: log2FC,
                        pValue: pValue,
                        negLogPValue: -Math.log10(pValue),
                        auc: auc,
                        avgExpression: avgExpression,
                        exprA: exprA,
                        exprB: exprB
                    });
                }

                return results;
            }

            // Tooltip functions
            function showTooltip(event, content) {
                elements.tooltip.innerHTML = content;
                elements.tooltip.style.opacity = '1';
                elements.tooltip.style.left = (event.pageX + 10) + 'px';
                elements.tooltip.style.top = (event.pageY - 10) + 'px';
            }

            function hideTooltip() {
                elements.tooltip.style.opacity = '0';
            }

            // Chart rendering functions
            function clearChart(container) {
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
            }

            function renderHeatmap() {
                const container = elements.heatmap;
                clearChart(container);

                if (!state.df) return;

                const width = container.clientWidth || 600;
                const height = container.clientHeight || 420;

                // Calculate dynamic margins based on content
                const variances = computeVariancePerGene();
                const indices = d3.range(state.df.length);
                indices.sort((a, b) => variances[b] - variances[a]);
                const topGenes = indices.slice(0, 50);
                const genes = topGenes.map(i => state.genes[i]);

                // Dynamic left margin based on longest gene name
                const maxGeneNameLength = Math.max(...genes.map(name => name.length));
                const dynamicLeftMargin = Math.max(60, Math.min(maxGeneNameLength * 7, 150));

                // Dynamic bottom margin based on longest class name
                const maxClassNameLength = Math.max(...state.classes.map(name => name.length));
                const dynamicBottomMargin = Math.max(80, Math.min(maxClassNameLength * 6 + 40, 120));

                const margin = {
                    top: 30,
                    right: 60,
                    bottom: dynamicBottomMargin,
                    left: dynamicLeftMargin
                };
                const innerW = width - margin.left - margin.right;
                const innerH = height - margin.top - margin.bottom;

                const classes = state.classes.slice();

                const x = d3.scaleBand().domain(classes).range([0, innerW]).padding(0.05);
                const y = d3.scaleBand().domain(genes).range([0, innerH]).padding(0.05);

                let maxVal = 0;
                for (const i of topGenes) {
                    for (const c of classes) {
                        maxVal = Math.max(maxVal, +state.df[i][c] || 0);
                    }
                }
                const colorScale = d3.scaleSequential(d3.interpolateViridis).domain([0, maxVal || 1]);

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                const cells = [];
                for (const i of topGenes) {
                    for (const c of classes) {
                        cells.push({
                            gene: state.genes[i],
                            class: c,
                            value: +state.df[i][c] || 0
                        });
                    }
                }

                g.selectAll('rect.cell')
                    .data(cells)
                    .join('rect')
                    .attr('class', 'cell')
                    .attr('x', d => x(d.class))
                    .attr('y', d => y(d.gene))
                    .attr('width', x.bandwidth())
                    .attr('height', y.bandwidth())
                    .attr('fill', d => colorScale(d.value))
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 0.5)
                    .on('mouseover', function(event, d) {
                        showTooltip(event, `
                            <strong>${d.gene}</strong><br>
                            Class: ${d.class}<br>
                            Expression: ${d.value.toFixed(3)}
                        `);
                    })
                    .on('mouseout', hideTooltip);

                // X-axis with selective labeling for classes
                const xAxis = d3.axisBottom(x);
                if (classes.length > 10) {
                    // Show every nth label to avoid crowding
                    const step = Math.ceil(classes.length / 16);
                    xAxis.tickValues(classes.filter((d, i) => i % step === 0));
                }

                g.append('g')
                    .attr('transform', `translate(0,${innerH})`)
                    .call(xAxis)
                    .selectAll('text')
                    .attr('transform', 'rotate(45)')
                    .style('text-anchor', 'start')
                    .style('font-size', '11px');

                // Y-axis with selective labeling for genes
                const yAxis = d3.axisLeft(y);
                if (genes.length > 15) {
                    // Show every nth label to avoid crowding
                    const step = Math.ceil(genes.length / 24);
                    yAxis.tickValues(genes.filter((d, i) => i % step === 0));
                }

                g.append('g')
                    .call(yAxis)
                    .selectAll('text')
                    .style('font-size', '10px');

                // Add colorbar
                const colorbarWidth = 20;
                const colorbarHeight = innerH;
                const colorbar = svg.append('g')
                    .attr('transform', `translate(${width - margin.right + 10}, ${margin.top})`);

                const colorbarScale = d3.scaleLinear()
                    .domain([0, maxVal])
                    .range([colorbarHeight, 0]);

                const colorbarAxis = d3.axisRight(colorbarScale)
                    .ticks(5)
                    .tickFormat(d3.format('.2f'));

                colorbar.selectAll('rect')
                    .data(d3.range(0, maxVal, maxVal / 100))
                    .join('rect')
                    .attr('x', 0)
                    .attr('y', d => colorbarScale(d))
                    .attr('width', colorbarWidth)
                    .attr('height', colorbarHeight / 100)
                    .attr('fill', d => colorScale(d));

                colorbar.append('g')
                    .attr('transform', `translate(${colorbarWidth}, 0)`)
                    .call(colorbarAxis);
            }

            function renderSpecificity() {
                const container = elements.specificity;
                clearChart(container);

                if (!state.df || !state.classA) return;

                const width = container.clientWidth || 600;
                const height = container.clientHeight || 420;

                // Calculate dynamic left margin based on longest gene name
                const specificityMap = specificityScores();
                const scores = specificityMap.get(state.classA);
                const indices = d3.range(scores.length);
                indices.sort((a, b) => scores[b] - scores[a]);
                const topIndices = indices.slice(0, 20);
                const geneNames = topIndices.map(i => state.genes[i]);
                const maxGeneNameLength = Math.max(...geneNames.map(name => name.length));
                const dynamicLeftMargin = Math.max(80, Math.min(maxGeneNameLength * 8, 200));

                const margin = { top: 20, right: 80, bottom: 40, left: dynamicLeftMargin };
                const innerW = width - margin.left - margin.right;
                const innerH = height - margin.top - margin.bottom;

                const data = topIndices.map(i => ({
                    gene: state.genes[i],
                    specificity: scores[i],
                    expression: +state.df[i][state.classA] || 0
                }));

                const y = d3.scaleBand()
                    .domain(data.map(d => d.gene))
                    .range([0, innerH])
                    .padding(0.1);

                const x = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.specificity) || 1])
                    .nice()
                    .range([0, innerW]);

                const colorScale = d3.scaleSequential(d3.interpolateViridis)
                    .domain([0, d3.max(data, d => d.expression) || 1]);

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                g.selectAll('rect.bar')
                    .data(data)
                    .join('rect')
                    .attr('class', 'bar')
                    .attr('x', 0)
                    .attr('y', d => y(d.gene))
                    .attr('width', d => x(d.specificity))
                    .attr('height', y.bandwidth())
                    .attr('fill', d => colorScale(d.expression))
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1)
                    .on('mouseover', function(event, d) {
                        showTooltip(event, `
                            <strong>${d.gene}</strong><br>
                            Specificity: ${d.specificity.toFixed(3)}<br>
                            Expression in ${state.classA}: ${d.expression.toFixed(3)}
                        `);
                    })
                    .on('mouseout', hideTooltip);

                g.append('g').call(d3.axisLeft(y));
                g.append('g')
                    .attr('transform', `translate(0,${innerH})`)
                    .call(d3.axisBottom(x));

                g.append('text')
                    .attr('x', innerW / 2)
                    .attr('y', innerH + 35)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text('Specificity Score');

                // Add colorbar for expression levels
                const colorbarWidth = 25;
                const colorbarHeight = Math.min(innerH * 0.8, 250);
                const colorbarY = (innerH - colorbarHeight) / 2;
                const maxExpression = d3.max(data, d => d.expression) || 1;

                const specificityColorbar = svg.append('g')
                    .attr('transform', `translate(${width - margin.right + 15}, ${margin.top + colorbarY})`);

                const specificityColorbarScale = d3.scaleLinear()
                    .domain([0, maxExpression])
                    .range([colorbarHeight, 0]);

                const specificityColorbarAxis = d3.axisRight(specificityColorbarScale)
                    .ticks(6)
                    .tickSize(6)
                    .tickFormat(d3.format('.0f'));

                // Create colorbar gradient
                const specificityGradient = svg.append('defs')
                    .append('linearGradient')
                    .attr('id', 'specificity-colorbar-gradient')
                    .attr('gradientUnits', 'userSpaceOnUse')
                    .attr('x1', 0).attr('y1', colorbarHeight)
                    .attr('x2', 0).attr('y2', 0);

                const numStops = 50;
                for (let i = 0; i <= numStops; i++) {
                    const value = (i / numStops) * maxExpression;
                    specificityGradient.append('stop')
                        .attr('offset', `${(i / numStops) * 100}%`)
                        .attr('stop-color', colorScale(value));
                }

                // Add title above colorbar
                specificityColorbar.append('text')
                    .attr('x', colorbarWidth / 2)
                    .attr('y', -15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', '600')
                    .style('fill', '#333')
                    .text('Expression');

                specificityColorbar.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', colorbarWidth)
                    .attr('height', colorbarHeight)
                    .style('fill', 'url(#specificity-colorbar-gradient)')
                    .attr('stroke', '#666')
                    .attr('stroke-width', 1);

                // Add tick marks and labels
                const specificityAxisGroup = specificityColorbar.append('g')
                    .attr('transform', `translate(${colorbarWidth}, 0)`)
                    .call(specificityColorbarAxis);

                // Style the axis
                specificityAxisGroup.selectAll('path, line')
                    .style('stroke', '#666')
                    .style('stroke-width', 1);

                specificityAxisGroup.selectAll('text')
                    .style('font-size', '11px')
                    .style('fill', '#333');

                // Add tick marks on the left side of the colorbar for better visibility
                const specificityLeftTicks = specificityColorbar.append('g');
                const specificityTickValues = specificityColorbarScale.ticks(6);

                specificityLeftTicks.selectAll('line')
                    .data(specificityTickValues)
                    .join('line')
                    .attr('x1', -3)
                    .attr('x2', 0)
                    .attr('y1', d => specificityColorbarScale(d))
                    .attr('y2', d => specificityColorbarScale(d))
                    .style('stroke', '#666')
                    .style('stroke-width', 1);
            }

            function renderPairwise() {
                const container = elements.pairwise;
                clearChart(container);

                if (!state.df || !state.classA || !state.classB) return;

                const width = container.clientWidth || 600;
                const height = container.clientHeight || 420;
                const margin = { top: 40, right: 80, bottom: 60, left: 60 };
                const innerW = width - margin.left - margin.right;
                const innerH = height - margin.top - margin.bottom;

                const exprA = state.df.map(r => +r[state.classA] || 0);
                const exprB = state.df.map(r => +r[state.classB] || 0);
                const mask = exprA.map((a, i) => (a >= state.minExpr) || (exprB[i] >= state.minExpr));

                const points = [];
                for (let i = 0; i < state.df.length; i++) {
                    if (!mask[i]) continue;
                    const a = exprA[i];
                    const b = exprB[i];
                    const foldChange = Math.abs(Math.max(a, 1e-6) / Math.max(b, 1e-6));
                    const minExpr = Math.min(a, b);
                    points.push({
                        gene: state.genes[i],
                        a: a,
                        b: b,
                        foldChange: foldChange,
                        minExpr: minExpr
                    });
                }

                const maxX = d3.max(points, d => d.a) || 1;
                const maxY = d3.max(points, d => d.b) || 1;

                // Use symmetric or independent ranges based on toggle
                let xMax, yMax;
                if (state.symmetricAxes) {
                    const maxVal = Math.max(maxX, maxY);
                    xMax = maxVal;
                    yMax = maxVal;
                } else {
                    xMax = maxX;
                    yMax = maxY;
                }

                const x = d3.scaleLinear().domain([0, xMax]).nice().range([0, innerW]);
                const y = d3.scaleLinear().domain([0, yMax]).nice().range([innerH, 0]);
                const radiusScale = d3.scaleSqrt()
                    .domain([0, d3.max(points, d => d.minExpr) || 1])
                    .range([2, 12]);
                const colorScale = d3.scaleSequential(d3.interpolateViridis)
                    .domain([0, d3.max(points, d => d.foldChange) || 1]);

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                // Diagonal line (draw to the minimum of the axis maxes to stay within bounds)
                const diagonalMax = Math.min(xMax, yMax);
                g.append('line')
                    .attr('x1', x(0))
                    .attr('y1', y(0))
                    .attr('x2', x(diagonalMax))
                    .attr('y2', y(diagonalMax))
                    .attr('stroke', '#ef4444')
                    .attr('stroke-dasharray', '4,4')
                    .attr('stroke-width', 2);

                g.selectAll('circle.point')
                    .data(points)
                    .join('circle')
                    .attr('class', 'point')
                    .attr('cx', d => x(d.a))
                    .attr('cy', d => y(d.b))
                    .attr('r', d => radiusScale(d.minExpr))
                    .attr('fill', d => colorScale(d.foldChange))
                    .attr('fill-opacity', 0.7)
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 0.5)
                    .on('mouseover', function(event, d) {
                        showTooltip(event, `
                            <strong>${d.gene}</strong><br>
                            ${state.classA}: ${d.a.toFixed(3)}<br>
                            ${state.classB}: ${d.b.toFixed(3)}<br>
                            Fold Change: ${d.foldChange.toFixed(2)}x
                        `);
                    })
                    .on('mouseout', hideTooltip);

                g.append('g')
                    .attr('transform', `translate(0,${innerH})`)
                    .call(d3.axisBottom(x));

                g.append('g').call(d3.axisLeft(y));

                g.append('text')
                    .attr('x', innerW / 2)
                    .attr('y', innerH + 45)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text(`${state.classA} Expression`);

                g.append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('x', -innerH / 2)
                    .attr('y', -40)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text(`${state.classB} Expression`);

                // Add colorbar for fold change
                const colorbarWidth = 25;
                const colorbarHeight = Math.min(innerH * 0.8, 250);
                const colorbarY = (innerH - colorbarHeight) / 2;
                const maxFoldChange = d3.max(points, d => d.foldChange) || 1;

                const colorbar = svg.append('g')
                    .attr('transform', `translate(${width - margin.right + 15}, ${margin.top + colorbarY})`);

                const colorbarScale = d3.scaleLinear()
                    .domain([0, maxFoldChange])
                    .range([colorbarHeight, 0]);

                const colorbarAxis = d3.axisRight(colorbarScale)
                    .ticks(6)
                    .tickSize(6)
                    .tickFormat(d3.format('.1f'));

                // Create colorbar gradient
                const gradient = svg.append('defs')
                    .append('linearGradient')
                    .attr('id', 'pairwise-colorbar-gradient')
                    .attr('gradientUnits', 'userSpaceOnUse')
                    .attr('x1', 0).attr('y1', colorbarHeight)
                    .attr('x2', 0).attr('y2', 0);

                const numStops = 50;
                for (let i = 0; i <= numStops; i++) {
                    const value = (i / numStops) * maxFoldChange;
                    gradient.append('stop')
                        .attr('offset', `${(i / numStops) * 100}%`)
                        .attr('stop-color', colorScale(value));
                }

                // Add title above colorbar
                colorbar.append('text')
                    .attr('x', colorbarWidth / 2)
                    .attr('y', -15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', '600')
                    .style('fill', '#333')
                    .text('Fold Change');

                colorbar.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', colorbarWidth)
                    .attr('height', colorbarHeight)
                    .style('fill', 'url(#pairwise-colorbar-gradient)')
                    .attr('stroke', '#666')
                    .attr('stroke-width', 1);

                // Add tick marks and labels
                const axisGroup = colorbar.append('g')
                    .attr('transform', `translate(${colorbarWidth}, 0)`)
                    .call(colorbarAxis);

                // Style the axis
                axisGroup.selectAll('path, line')
                    .style('stroke', '#666')
                    .style('stroke-width', 1);

                axisGroup.selectAll('text')
                    .style('font-size', '11px')
                    .style('fill', '#333');

                // Add tick marks on the left side of the colorbar for better visibility
                const leftTicks = colorbar.append('g');
                const tickValues = colorbarScale.ticks(6);

                leftTicks.selectAll('line')
                    .data(tickValues)
                    .join('line')
                    .attr('x1', -3)
                    .attr('x2', 0)
                    .attr('y1', d => colorbarScale(d))
                    .attr('y2', d => colorbarScale(d))
                    .style('stroke', '#666')
                    .style('stroke-width', 1);

                // Add checkbox for axis scaling toggle - positioned above chart area, below title
                const checkboxGroup = svg.append('g')
                    .attr('transform', `translate(${margin.left + 10}, ${margin.top - 10})`);

                // Background for checkbox area
                checkboxGroup.append('rect')
                    .attr('x', -8)
                    .attr('y', -18)
                    .attr('width', 130)
                    .attr('height', 22)
                    .attr('fill', 'rgba(255, 255, 255, 0.95)')
                    .attr('stroke', '#ccc')
                    .attr('stroke-width', 1)
                    .attr('rx', 4);

                // Modern checkbox circle
                const checkbox = checkboxGroup.append('circle')
                    .attr('cx', 7)
                    .attr('cy', -7)
                    .attr('r', 6)
                    .attr('fill', state.symmetricAxes ? '#667eea' : 'white')
                    .attr('stroke', '#667eea')
                    .attr('stroke-width', 2)
                    .style('cursor', 'pointer');

                // Inner dot for checked state
                if (state.symmetricAxes) {
                    checkboxGroup.append('circle')
                        .attr('cx', 7)
                        .attr('cy', -7)
                        .attr('r', 3)
                        .attr('fill', 'white')
                        .style('pointer-events', 'none');
                }

                // Label
                checkboxGroup.append('text')
                    .attr('x', 18)
                    .attr('y', -3)
                    .style('font-size', '11px')
                    .style('fill', '#333')
                    .style('font-weight', '500')
                    .style('pointer-events', 'none')
                    .text('Symmetric axes');

                // Click handler
                checkboxGroup
                    .style('cursor', 'pointer')
                    .on('click', function() {
                        state.symmetricAxes = !state.symmetricAxes;
                        renderPairwise();
                    });
            }

            function renderDiscriminators() {
                const container = elements.discriminators;
                clearChart(container);

                if (!state.df || !state.classA || !state.classB) return;

                const width = container.clientWidth || 600;
                const height = container.clientHeight || 420;

                // Calculate discrimination scores first to determine top genes and dynamic margin
                const scores = discriminationScores(state.classA, state.classB, state.minExpr);
                const indices = d3.range(scores.length);
                indices.sort((a, b) => scores[b] - scores[a]);
                const topIndices = indices.slice(0, 20);
                const geneNames = topIndices.map(i => state.genes[i]);
                const maxGeneNameLength = Math.max(...geneNames.map(name => name.length));
                const dynamicLeftMargin = Math.max(80, Math.min(maxGeneNameLength * 8, 200));

                const margin = { top: 20, right: 20, bottom: 40, left: dynamicLeftMargin };
                const innerW = width - margin.left - margin.right;
                const innerH = height - margin.top - margin.bottom;

                const data = topIndices.map(i => {
                    const exprA = +state.df[i][state.classA] || 0;
                    const exprB = +state.df[i][state.classB] || 0;
                    const foldChange = Math.abs(Math.max(exprA, 1e-6) / Math.max(exprB, 1e-6));
                    return {
                        gene: state.genes[i],
                        score: scores[i],
                        exprA: exprA,
                        exprB: exprB,
                        foldChange: foldChange
                    };
                });

                const y = d3.scaleBand()
                    .domain(data.map(d => d.gene))
                    .range([0, innerH])
                    .padding(0.1);

                const x = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.score) || 1])
                    .nice()
                    .range([0, innerW]);

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                g.selectAll('rect.bar')
                    .data(data)
                    .join('rect')
                    .attr('class', 'bar')
                    .attr('x', 0)
                    .attr('y', d => y(d.gene))
                    .attr('width', d => x(d.score))
                    .attr('height', y.bandwidth())
                    .attr('fill', '#60a5fa')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1)
                    .on('mouseover', function(event, d) {
                        showTooltip(event, `
                            <strong>${d.gene}</strong><br>
                            Discrimination Score: ${d.score.toFixed(3)}<br>
                            ${state.classA}: ${d.exprA.toFixed(3)}<br>
                            ${state.classB}: ${d.exprB.toFixed(3)}<br>
                            Fold Change: ${d.foldChange.toFixed(2)}x
                        `);
                    })
                    .on('mouseout', hideTooltip);

                g.append('g').call(d3.axisLeft(y));
                g.append('g')
                    .attr('transform', `translate(0,${innerH})`)
                    .call(d3.axisBottom(x));

                g.append('text')
                    .attr('x', innerW / 2)
                    .attr('y', innerH + 35)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text('Discrimination Score');
            }

            function renderVolcano() {
                const container = elements.volcano;
                clearChart(container);

                if (!state.df || !state.classA || !state.classB) return;

                const width = container.clientWidth || 600;
                const height = container.clientHeight || 420;
                const margin = { top: 40, right: 80, bottom: 60, left: 60 };
                const innerW = width - margin.left - margin.right;
                const innerH = height - margin.top - margin.bottom;

                // Perform volcano analysis
                const volcanoData = volcanoAnalysis(state.classA, state.classB, state.minExpr);

                if (volcanoData.length === 0) {
                    container.innerHTML = '<div class="loading">No genes meet expression threshold</div>';
                    return;
                }

                // Define significance thresholds
                const pValueThreshold = 0.05;
                const foldChangeThreshold = 1.5; // 1.5x fold change
                const aucThreshold = 0.7; // Good biomarker threshold

                // Categorize genes
                volcanoData.forEach(d => {
                    const isSignificant = d.pValue < pValueThreshold;
                    const isFoldChangeHigh = Math.abs(d.log2FC) > Math.log2(foldChangeThreshold);
                    const isGoodBiomarker = d.auc > aucThreshold;

                    if (isSignificant && isFoldChangeHigh && isGoodBiomarker) {
                        d.category = 'High-quality biomarker';
                        d.color = '#dc2626'; // Red for best markers
                    } else if (isSignificant && isFoldChangeHigh) {
                        d.category = 'Significant DE';
                        d.color = '#f97316'; // Bright orange for significant
                    } else if (isGoodBiomarker) {
                        d.category = 'Good biomarker';
                        d.color = '#2563eb'; // Blue for good biomarkers
                    } else {
                        d.category = 'Not significant';
                        d.color = '#6b7280'; // Gray for non-significant
                    }
                });

                // Set up scales
                const maxAbsLog2FC = d3.max(volcanoData, d => Math.abs(d.log2FC)) || 2;
                const maxNegLogP = d3.max(volcanoData, d => d.negLogPValue) || 2;

                const x = d3.scaleLinear()
                    .domain([-maxAbsLog2FC * 1.1, maxAbsLog2FC * 1.1])
                    .nice()
                    .range([0, innerW]);

                const y = d3.scaleLinear()
                    .domain([0, maxNegLogP * 1.1])
                    .nice()
                    .range([innerH, 0]);

                const radiusScale = d3.scaleSqrt()
                    .domain([0, d3.max(volcanoData, d => d.avgExpression) || 1])
                    .range([3, 12]);

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                // Add threshold lines
                // Vertical lines for fold change thresholds
                const fcThresholdLog2 = Math.log2(foldChangeThreshold);
                g.append('line')
                    .attr('x1', x(-fcThresholdLog2))
                    .attr('x2', x(-fcThresholdLog2))
                    .attr('y1', y(0))
                    .attr('y2', y(maxNegLogP * 1.1))
                    .attr('stroke', '#94a3b8')
                    .attr('stroke-dasharray', '3,3')
                    .attr('stroke-width', 1);

                g.append('line')
                    .attr('x1', x(fcThresholdLog2))
                    .attr('x2', x(fcThresholdLog2))
                    .attr('y1', y(0))
                    .attr('y2', y(maxNegLogP * 1.1))
                    .attr('stroke', '#94a3b8')
                    .attr('stroke-dasharray', '3,3')
                    .attr('stroke-width', 1);

                // Horizontal line for p-value threshold
                const pThresholdNegLog = -Math.log10(pValueThreshold);
                g.append('line')
                    .attr('x1', x(-maxAbsLog2FC * 1.1))
                    .attr('x2', x(maxAbsLog2FC * 1.1))
                    .attr('y1', y(pThresholdNegLog))
                    .attr('y2', y(pThresholdNegLog))
                    .attr('stroke', '#94a3b8')
                    .attr('stroke-dasharray', '3,3')
                    .attr('stroke-width', 1);

                // Add vertical line at log2FC = 0
                g.append('line')
                    .attr('x1', x(0))
                    .attr('x2', x(0))
                    .attr('y1', y(0))
                    .attr('y2', y(maxNegLogP * 1.1))
                    .attr('stroke', '#cbd5e1')
                    .attr('stroke-width', 1);

                // Plot points
                g.selectAll('circle.volcano-point')
                    .data(volcanoData)
                    .join('circle')
                    .attr('class', 'volcano-point')
                    .attr('cx', d => x(d.log2FC))
                    .attr('cy', d => y(d.negLogPValue))
                    .attr('r', d => radiusScale(d.avgExpression))
                    .attr('fill', d => d.color)
                    .attr('fill-opacity', 0.7)
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 0.5)
                    .on('mouseover', function(event, d) {
                        showTooltip(event, `
                            <strong>${d.gene}</strong><br>
                            Log2 Fold Change: ${d.log2FC.toFixed(2)}<br>
                            P-value: ${d.pValue.toExponential(2)}<br>
                            AUC Score: ${d.auc.toFixed(3)}<br>
                            ${state.classA}: ${d.exprA.toFixed(3)}<br>
                            ${state.classB}: ${d.exprB.toFixed(3)}<br>
                            Category: ${d.category}
                        `);
                    })
                    .on('mouseout', hideTooltip);

                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerH})`)
                    .call(d3.axisBottom(x));

                g.append('g').call(d3.axisLeft(y));

                // Add axis labels
                g.append('text')
                    .attr('x', innerW / 2)
                    .attr('y', innerH + 45)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text(`Log2 Fold Change (${state.classA} / ${state.classB})`);

                g.append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('x', -innerH / 2)
                    .attr('y', -40)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text('-Log10(P-value)');

                // Add legend
                const legend = svg.append('g')
                    .attr('transform', `translate(${width - margin.right + 10}, ${margin.top})`);

                const categories = [
                    { name: 'High-quality biomarker', color: '#dc2626' },
                    { name: 'Significant DE', color: '#f97316' },
                    { name: 'Good biomarker', color: '#2563eb' },
                    { name: 'Not significant', color: '#6b7280' }
                ];

                const legendItems = legend.selectAll('.legend-item')
                    .data(categories)
                    .join('g')
                    .attr('class', 'legend-item')
                    .attr('transform', (d, i) => `translate(0, ${i * 20})`);

                legendItems.append('circle')
                    .attr('cx', 6)
                    .attr('cy', 0)
                    .attr('r', 5)
                    .attr('fill', d => d.color);

                legendItems.append('text')
                    .attr('x', 16)
                    .attr('y', 4)
                    .style('font-size', '10px')
                    .style('fill', '#333')
                    .text(d => d.name);

                // Add threshold annotations
                const annotations = g.append('g').attr('class', 'annotations');

                // P-value threshold annotation
                annotations.append('text')
                    .attr('x', x(maxAbsLog2FC * 0.8))
                    .attr('y', y(pThresholdNegLog) - 5)
                    .style('font-size', '10px')
                    .style('fill', '#64748b')
                    .text(`p = ${pValueThreshold}`);

                // Fold change threshold annotations
                annotations.append('text')
                    .attr('x', x(fcThresholdLog2) + 5)
                    .attr('y', y(maxNegLogP * 0.9))
                    .style('font-size', '10px')
                    .style('fill', '#64748b')
                    .text(`${foldChangeThreshold}x`);

                annotations.append('text')
                    .attr('x', x(-fcThresholdLog2) - 25)
                    .attr('y', y(maxNegLogP * 0.9))
                    .style('font-size', '10px')
                    .style('fill', '#64748b')
                    .text(`${foldChangeThreshold}x`);

                // Summary statistics
                const summaryStats = volcanoData.reduce((acc, d) => {
                    acc[d.category] = (acc[d.category] || 0) + 1;
                    return acc;
                }, {});

                const summary = svg.append('g')
                    .attr('transform', `translate(${margin.left}, ${height - 40})`);

                const statsText = Object.entries(summaryStats)
                    .map(([cat, count]) => `${cat}: ${count}`)
                    .join(' | ');

                summary.append('text')
                    .style('font-size', '10px')
                    .style('fill', '#64748b')
                    .text(`Gene counts: ${statsText}`);
            }

            function updateChartTitles() {
                if (state.classA && state.classB) {
                    elements.specificityTitle.textContent = `Most Specific Genes for ${state.classA}`;
                    elements.pairwiseTitle.textContent = `${state.classA} vs ${state.classB} Gene Counts`;
                    // Skip title updates for hidden charts
                } else {
                    elements.specificityTitle.textContent = 'Gene Specificity Analysis';
                    elements.pairwiseTitle.textContent = 'Pairwise Class Comparison';
                    // Skip title updates for hidden charts
                }
            }

            function renderAllCharts() {
                if (!state.df || !state.classA || !state.classB) return;

                clearError();
                updateChartTitles();
                try {
                    renderHeatmap();
                    renderSpecificity();
                    renderPairwise();
                    // renderDiscriminators(); // Hidden - TBA
                    // renderVolcano(); // Hidden - TBA
                } catch (error) {
                    console.error('Rendering error:', error);
                    showError(`Rendering error: ${error.message}`);
                }
            }

            // Event listeners
            elements.file.addEventListener('change', async (e) => {
                const file = e.target.files && e.target.files[0];
                if (!file) return;

                showStatus('Reading CSV file...', 0);
                try {
                    const text = await file.text();
                    await handleCSVText(text);

                    // Update file input label
                    const label = elements.file.nextElementSibling;
                    label.textContent = `üìÅ ${file.name}`;
                } catch (error) {
                    showError(`Error reading file: ${error.message}`);
                    showStatus('');
                }
            });

            elements.classA.addEventListener('change', () => {
                state.classA = elements.classA.value;
                renderAllCharts();
            });

            elements.classB.addEventListener('change', () => {
                state.classB = elements.classB.value;
                renderAllCharts();
            });

            elements.minExpr.addEventListener('input', () => {
                state.minExpr = +elements.minExpr.value;
                elements.minExprVal.textContent = state.minExpr.toFixed(2);
                renderAllCharts();
            });

            // Window resize handler
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(renderAllCharts, 250);
            });

            // Initialize
            showStatus('Ready - Upload a CSV file to begin analysis');
        })();
    </script>
</body>
</html>
