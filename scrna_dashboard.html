<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scRNA Reference Explorer Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8fafc;
            color: #334155;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            text-align: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .controls-section {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            align-items: end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-weight: 600;
            color: #374151;
            font-size: 0.9rem;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 0.75rem 1rem;
            background: #f1f5f9;
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .file-input-label:hover {
            background: #e2e8f0;
            border-color: #94a3b8;
        }

        select, input[type="range"] {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: white;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }

        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .slider-wrapper {
            position: relative;
        }

        .slider-value {
            background: #667eea;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 2rem;
        }

        .chart-panel {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .chart-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .chart-panel h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #f1f5f9;
        }

        .chart {
            width: 100%;
            height: 450px;
            border-radius: 8px;
            overflow: hidden;
        }

        .status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #1f2937;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            z-index: 1000;
            transform: translateY(-100%);
            transition: transform 0.3s;
        }

        .status-bar.show {
            transform: translateY(0);
        }

        .error-message {
            background: #fef2f2;
            color: #dc2626;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #fecaca;
            margin-bottom: 1rem;
            display: none;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            font-size: 1.1rem;
            color: #6b7280;
        }

        .loading::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid #e5e7eb;
            border-top-color: #667eea;
            border-radius: 50%;
            margin-left: 1rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        .back-button {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: white;
            color: #667eea;
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
            z-index: 999;
        }

        .back-button:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
        }

        .instructions {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
            font-size: 0.9rem;
            color: #0c4a6e;
        }

        .instructions h4 {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-dsv@3"></script>
    <script src="https://unpkg.com/d3-scale-chromatic@3"></script>
    <script src="https://unpkg.com/d3-array@3"></script>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Back to Viewer</a>

    <div class="status-bar" id="statusBar"></div>

    <header class="header">
        <h1>scRNA Reference Explorer</h1>
        <p>Analyze single-cell reference data for spatial transcriptomics</p>
    </header>

    <div class="container">
        <div class="instructions">
            <h4>How to use:</h4>
            1. Upload a CSV file with genes as rows and cell classes as columns<br>
            2. Select two classes to compare using the dropdowns<br>
            3. Adjust the minimum expression threshold to filter low-expression genes<br>
            4. Explore the four interactive visualizations below
        </div>

        <div class="controls-section">
            <div class="controls-grid">
                <div class="control-group">
                    <label for="csvFile">Upload CSV File</label>
                    <div class="file-input-wrapper">
                        <input id="csvFile" type="file" accept=".csv,text/csv" class="file-input">
                        <label for="csvFile" class="file-input-label">
                            üìÅ Choose CSV file (genes √ó classes)
                        </label>
                    </div>
                </div>

                <div class="control-group">
                    <label for="classA">Class A</label>
                    <select id="classA">
                        <option value="">Select Class A</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="classB">Class B</label>
                    <select id="classB">
                        <option value="">Select Class B</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="minExpr">Min Expression Threshold<span class="slider-value" id="minExprVal">0.10</span></label>
                    <input id="minExpr" type="range" min="0" max="2" step="0.1" value="0.1">
                </div>
            </div>
        </div>

        <div id="error" class="error-message"></div>

        <div class="charts-grid">
            <div class="chart-panel">
                <h3>Expression Heatmap</h3>
                <div id="heatmap" class="chart">
                    <div class="loading">Loading data...</div>
                </div>
            </div>

            <div class="chart-panel">
                <h3 id="specificityTitle">Gene Specificity Analysis</h3>
                <div id="specificity" class="chart">
                    <div class="loading">Select classes to begin</div>
                </div>
            </div>

            <div class="chart-panel">
                <h3 id="pairwiseTitle">Pairwise Class Comparison</h3>
                <div id="pairwise" class="chart">
                    <div class="loading">Select classes to compare</div>
                </div>
            </div>

            <div class="chart-panel">
                <h3 id="discriminatorsTitle">Top Discriminating Genes</h3>
                <div id="discriminators" class="chart">
                    <div class="loading">Select classes to analyze</div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Enhanced scRNA Explorer Dashboard
        (function() {
            const state = {
                df: null,
                genes: [],
                classes: [],
                classA: null,
                classB: null,
                minExpr: 0.1,
                symmetricAxes: true,
            };

            const elements = {
                file: document.getElementById('csvFile'),
                classA: document.getElementById('classA'),
                classB: document.getElementById('classB'),
                minExpr: document.getElementById('minExpr'),
                minExprVal: document.getElementById('minExprVal'),
                error: document.getElementById('error'),
                statusBar: document.getElementById('statusBar'),
                heatmap: document.getElementById('heatmap'),
                specificity: document.getElementById('specificity'),
                pairwise: document.getElementById('pairwise'),
                discriminators: document.getElementById('discriminators'),
                tooltip: document.getElementById('tooltip'),
                specificityTitle: document.getElementById('specificityTitle'),
                pairwiseTitle: document.getElementById('pairwiseTitle'),
                discriminatorsTitle: document.getElementById('discriminatorsTitle')
            };

            // Utility functions
            function showStatus(message, duration = 3000) {
                elements.statusBar.textContent = message;
                elements.statusBar.classList.add('show');
                if (duration > 0) {
                    setTimeout(() => {
                        elements.statusBar.classList.remove('show');
                    }, duration);
                }
            }

            function showError(message) {
                elements.error.textContent = message;
                elements.error.style.display = message ? 'block' : 'none';
            }

            function clearError() {
                showError('');
            }

            // CSV handling
            async function handleCSVText(text) {
                clearError();
                showStatus('Processing CSV data...', 0);

                try {
                    let data = d3.csvParse(text);
                    if (!data.length) {
                        throw new Error('CSV file is empty');
                    }

                    // Detect gene column
                    const cols = data.columns;
                    const geneCol = cols.find(c => c.toLowerCase() === 'gene') ||
                                   cols.find(c => c.toLowerCase().includes('unnamed')) ||
                                   cols[0];

                    // Parse numeric columns
                    const classCols = cols.filter(c => c !== geneCol);
                    if (classCols.length < 2) {
                        throw new Error('Need at least 2 class columns for analysis');
                    }

                    // Convert to numeric values
                    data.forEach(row => {
                        classCols.forEach(c => {
                            const v = +row[c];
                            row[c] = Number.isFinite(v) ? v : 0;
                        });
                    });

                    state.df = data;
                    state.genes = data.map(d => d[geneCol]);
                    state.classes = classCols;
                    state.classA = state.classes[0] || null;
                    state.classB = state.classes[1] || state.classes[0] || null;

                    populateClassDropdowns();
                    renderAllCharts();
                    showStatus(`Loaded ${state.genes.length} genes across ${state.classes.length} classes`);
                } catch (error) {
                    showError(`Error processing CSV: ${error.message}`);
                    showStatus('');
                }
            }

            function populateClassDropdowns() {
                const options = state.classes.map(c => `<option value="${c}">${c}</option>`).join('');
                elements.classA.innerHTML = '<option value="">Select Class A</option>' + options;
                elements.classB.innerHTML = '<option value="">Select Class B</option>' + options;
                elements.classA.value = state.classA || '';
                elements.classB.value = state.classB || '';
            }

            // Data analysis functions
            function computeVariancePerGene() {
                return state.df.map(row => {
                    const vals = state.classes.map(c => +row[c] || 0);
                    return d3.variance(vals) ?? 0;
                });
            }

            function specificityScores() {
                const totals = state.df.map(row => d3.sum(state.classes, c => +row[c] || 0));
                const result = new Map();

                for (const className of state.classes) {
                    const arr = new Float64Array(state.df.length);
                    for (let i = 0; i < state.df.length; i++) {
                        const classExpr = +state.df[i][className] || 0;
                        const total = totals[i] || 0;
                        arr[i] = total > 1e-10 ? classExpr / total : 0;
                    }
                    result.set(className, arr);
                }
                return result;
            }

            function discriminationScores(classA, classB, minExprThreshold) {
                const n = state.df.length;
                const arr = new Float64Array(n);

                for (let i = 0; i < n; i++) {
                    const a = Math.max(+state.df[i][classA] || 0, 0);
                    const b = Math.max(+state.df[i][classB] || 0, 0);
                    const aSafe = Math.max(a, 1e-6);
                    const bSafe = Math.max(b, 1e-6);
                    const foldChange = Math.abs(aSafe / bSafe);
                    const reliability = Math.sqrt(Math.max(Math.min(a, b), 0));
                    let score = foldChange * reliability;

                    if (a < minExprThreshold && b < minExprThreshold) {
                        score *= 0.1;
                    }
                    arr[i] = score;
                }
                return arr;
            }

            // Tooltip functions
            function showTooltip(event, content) {
                elements.tooltip.innerHTML = content;
                elements.tooltip.style.opacity = '1';
                elements.tooltip.style.left = (event.pageX + 10) + 'px';
                elements.tooltip.style.top = (event.pageY - 10) + 'px';
            }

            function hideTooltip() {
                elements.tooltip.style.opacity = '0';
            }

            // Chart rendering functions
            function clearChart(container) {
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
            }

            function renderHeatmap() {
                const container = elements.heatmap;
                clearChart(container);

                if (!state.df) return;

                const width = container.clientWidth || 600;
                const height = container.clientHeight || 420;

                // Calculate dynamic margins based on content
                const variances = computeVariancePerGene();
                const indices = d3.range(state.df.length);
                indices.sort((a, b) => variances[b] - variances[a]);
                const topGenes = indices.slice(0, 50);
                const genes = topGenes.map(i => state.genes[i]);

                // Dynamic left margin based on longest gene name
                const maxGeneNameLength = Math.max(...genes.map(name => name.length));
                const dynamicLeftMargin = Math.max(60, Math.min(maxGeneNameLength * 7, 150));

                // Dynamic bottom margin based on longest class name
                const maxClassNameLength = Math.max(...state.classes.map(name => name.length));
                const dynamicBottomMargin = Math.max(80, Math.min(maxClassNameLength * 6 + 40, 120));

                const margin = {
                    top: 30,
                    right: 60,
                    bottom: dynamicBottomMargin,
                    left: dynamicLeftMargin
                };
                const innerW = width - margin.left - margin.right;
                const innerH = height - margin.top - margin.bottom;

                const classes = state.classes.slice();

                const x = d3.scaleBand().domain(classes).range([0, innerW]).padding(0.05);
                const y = d3.scaleBand().domain(genes).range([0, innerH]).padding(0.05);

                let maxVal = 0;
                for (const i of topGenes) {
                    for (const c of classes) {
                        maxVal = Math.max(maxVal, +state.df[i][c] || 0);
                    }
                }
                const colorScale = d3.scaleSequential(d3.interpolateViridis).domain([0, maxVal || 1]);

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                const cells = [];
                for (const i of topGenes) {
                    for (const c of classes) {
                        cells.push({
                            gene: state.genes[i],
                            class: c,
                            value: +state.df[i][c] || 0
                        });
                    }
                }

                g.selectAll('rect.cell')
                    .data(cells)
                    .join('rect')
                    .attr('class', 'cell')
                    .attr('x', d => x(d.class))
                    .attr('y', d => y(d.gene))
                    .attr('width', x.bandwidth())
                    .attr('height', y.bandwidth())
                    .attr('fill', d => colorScale(d.value))
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 0.5)
                    .on('mouseover', function(event, d) {
                        showTooltip(event, `
                            <strong>${d.gene}</strong><br>
                            Class: ${d.class}<br>
                            Expression: ${d.value.toFixed(3)}
                        `);
                    })
                    .on('mouseout', hideTooltip);

                // X-axis with selective labeling for classes
                const xAxis = d3.axisBottom(x);
                if (classes.length > 10) {
                    // Show every nth label to avoid crowding
                    const step = Math.ceil(classes.length / 16);
                    xAxis.tickValues(classes.filter((d, i) => i % step === 0));
                }

                g.append('g')
                    .attr('transform', `translate(0,${innerH})`)
                    .call(xAxis)
                    .selectAll('text')
                    .attr('transform', 'rotate(45)')
                    .style('text-anchor', 'start')
                    .style('font-size', '11px');

                // Y-axis with selective labeling for genes
                const yAxis = d3.axisLeft(y);
                if (genes.length > 15) {
                    // Show every nth label to avoid crowding
                    const step = Math.ceil(genes.length / 24);
                    yAxis.tickValues(genes.filter((d, i) => i % step === 0));
                }

                g.append('g')
                    .call(yAxis)
                    .selectAll('text')
                    .style('font-size', '10px');

                // Add colorbar
                const colorbarWidth = 20;
                const colorbarHeight = innerH;
                const colorbar = svg.append('g')
                    .attr('transform', `translate(${width - margin.right + 10}, ${margin.top})`);

                const colorbarScale = d3.scaleLinear()
                    .domain([0, maxVal])
                    .range([colorbarHeight, 0]);

                const colorbarAxis = d3.axisRight(colorbarScale)
                    .ticks(5)
                    .tickFormat(d3.format('.2f'));

                colorbar.selectAll('rect')
                    .data(d3.range(0, maxVal, maxVal / 100))
                    .join('rect')
                    .attr('x', 0)
                    .attr('y', d => colorbarScale(d))
                    .attr('width', colorbarWidth)
                    .attr('height', colorbarHeight / 100)
                    .attr('fill', d => colorScale(d));

                colorbar.append('g')
                    .attr('transform', `translate(${colorbarWidth}, 0)`)
                    .call(colorbarAxis);
            }

            function renderSpecificity() {
                const container = elements.specificity;
                clearChart(container);

                if (!state.df || !state.classA) return;

                const width = container.clientWidth || 600;
                const height = container.clientHeight || 420;

                // Calculate dynamic left margin based on longest gene name
                const specificityMap = specificityScores();
                const scores = specificityMap.get(state.classA);
                const indices = d3.range(scores.length);
                indices.sort((a, b) => scores[b] - scores[a]);
                const topIndices = indices.slice(0, 20);
                const geneNames = topIndices.map(i => state.genes[i]);
                const maxGeneNameLength = Math.max(...geneNames.map(name => name.length));
                const dynamicLeftMargin = Math.max(80, Math.min(maxGeneNameLength * 8, 200));

                const margin = { top: 20, right: 80, bottom: 40, left: dynamicLeftMargin };
                const innerW = width - margin.left - margin.right;
                const innerH = height - margin.top - margin.bottom;

                const data = topIndices.map(i => ({
                    gene: state.genes[i],
                    specificity: scores[i],
                    expression: +state.df[i][state.classA] || 0
                }));

                const y = d3.scaleBand()
                    .domain(data.map(d => d.gene))
                    .range([0, innerH])
                    .padding(0.1);

                const x = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.specificity) || 1])
                    .nice()
                    .range([0, innerW]);

                const colorScale = d3.scaleSequential(d3.interpolateViridis)
                    .domain([0, d3.max(data, d => d.expression) || 1]);

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                g.selectAll('rect.bar')
                    .data(data)
                    .join('rect')
                    .attr('class', 'bar')
                    .attr('x', 0)
                    .attr('y', d => y(d.gene))
                    .attr('width', d => x(d.specificity))
                    .attr('height', y.bandwidth())
                    .attr('fill', d => colorScale(d.expression))
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1)
                    .on('mouseover', function(event, d) {
                        showTooltip(event, `
                            <strong>${d.gene}</strong><br>
                            Specificity: ${d.specificity.toFixed(3)}<br>
                            Expression in ${state.classA}: ${d.expression.toFixed(3)}
                        `);
                    })
                    .on('mouseout', hideTooltip);

                g.append('g').call(d3.axisLeft(y));
                g.append('g')
                    .attr('transform', `translate(0,${innerH})`)
                    .call(d3.axisBottom(x));

                g.append('text')
                    .attr('x', innerW / 2)
                    .attr('y', innerH + 35)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text('Specificity Score');

                // Add colorbar for expression levels
                const colorbarWidth = 25;
                const colorbarHeight = Math.min(innerH * 0.8, 250);
                const colorbarY = (innerH - colorbarHeight) / 2;
                const maxExpression = d3.max(data, d => d.expression) || 1;

                const specificityColorbar = svg.append('g')
                    .attr('transform', `translate(${width - margin.right + 15}, ${margin.top + colorbarY})`);

                const specificityColorbarScale = d3.scaleLinear()
                    .domain([0, maxExpression])
                    .range([colorbarHeight, 0]);

                const specificityColorbarAxis = d3.axisRight(specificityColorbarScale)
                    .ticks(6)
                    .tickSize(6)
                    .tickFormat(d3.format('.0f'));

                // Create colorbar gradient
                const specificityGradient = svg.append('defs')
                    .append('linearGradient')
                    .attr('id', 'specificity-colorbar-gradient')
                    .attr('gradientUnits', 'userSpaceOnUse')
                    .attr('x1', 0).attr('y1', colorbarHeight)
                    .attr('x2', 0).attr('y2', 0);

                const numStops = 50;
                for (let i = 0; i <= numStops; i++) {
                    const value = (i / numStops) * maxExpression;
                    specificityGradient.append('stop')
                        .attr('offset', `${(i / numStops) * 100}%`)
                        .attr('stop-color', colorScale(value));
                }

                // Add title above colorbar
                specificityColorbar.append('text')
                    .attr('x', colorbarWidth / 2)
                    .attr('y', -15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', '600')
                    .style('fill', '#333')
                    .text('Expression');

                specificityColorbar.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', colorbarWidth)
                    .attr('height', colorbarHeight)
                    .style('fill', 'url(#specificity-colorbar-gradient)')
                    .attr('stroke', '#666')
                    .attr('stroke-width', 1);

                // Add tick marks and labels
                const specificityAxisGroup = specificityColorbar.append('g')
                    .attr('transform', `translate(${colorbarWidth}, 0)`)
                    .call(specificityColorbarAxis);

                // Style the axis
                specificityAxisGroup.selectAll('path, line')
                    .style('stroke', '#666')
                    .style('stroke-width', 1);

                specificityAxisGroup.selectAll('text')
                    .style('font-size', '11px')
                    .style('fill', '#333');

                // Add tick marks on the left side of the colorbar for better visibility
                const specificityLeftTicks = specificityColorbar.append('g');
                const specificityTickValues = specificityColorbarScale.ticks(6);

                specificityLeftTicks.selectAll('line')
                    .data(specificityTickValues)
                    .join('line')
                    .attr('x1', -3)
                    .attr('x2', 0)
                    .attr('y1', d => specificityColorbarScale(d))
                    .attr('y2', d => specificityColorbarScale(d))
                    .style('stroke', '#666')
                    .style('stroke-width', 1);
            }

            function renderPairwise() {
                const container = elements.pairwise;
                clearChart(container);

                if (!state.df || !state.classA || !state.classB) return;

                const width = container.clientWidth || 600;
                const height = container.clientHeight || 420;
                const margin = { top: 40, right: 80, bottom: 60, left: 60 };
                const innerW = width - margin.left - margin.right;
                const innerH = height - margin.top - margin.bottom;

                const exprA = state.df.map(r => +r[state.classA] || 0);
                const exprB = state.df.map(r => +r[state.classB] || 0);
                const mask = exprA.map((a, i) => (a >= state.minExpr) || (exprB[i] >= state.minExpr));

                const points = [];
                for (let i = 0; i < state.df.length; i++) {
                    if (!mask[i]) continue;
                    const a = exprA[i];
                    const b = exprB[i];
                    const foldChange = Math.abs(Math.max(a, 1e-6) / Math.max(b, 1e-6));
                    const minExpr = Math.min(a, b);
                    points.push({
                        gene: state.genes[i],
                        a: a,
                        b: b,
                        foldChange: foldChange,
                        minExpr: minExpr
                    });
                }

                const maxX = d3.max(points, d => d.a) || 1;
                const maxY = d3.max(points, d => d.b) || 1;

                // Use symmetric or independent ranges based on toggle
                let xMax, yMax;
                if (state.symmetricAxes) {
                    const maxVal = Math.max(maxX, maxY);
                    xMax = maxVal;
                    yMax = maxVal;
                } else {
                    xMax = maxX;
                    yMax = maxY;
                }

                const x = d3.scaleLinear().domain([0, xMax]).nice().range([0, innerW]);
                const y = d3.scaleLinear().domain([0, yMax]).nice().range([innerH, 0]);
                const radiusScale = d3.scaleSqrt()
                    .domain([0, d3.max(points, d => d.minExpr) || 1])
                    .range([2, 12]);
                const colorScale = d3.scaleSequential(d3.interpolateViridis)
                    .domain([0, d3.max(points, d => d.foldChange) || 1]);

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                // Diagonal line (draw to the minimum of the axis maxes to stay within bounds)
                const diagonalMax = Math.min(xMax, yMax);
                g.append('line')
                    .attr('x1', x(0))
                    .attr('y1', y(0))
                    .attr('x2', x(diagonalMax))
                    .attr('y2', y(diagonalMax))
                    .attr('stroke', '#ef4444')
                    .attr('stroke-dasharray', '4,4')
                    .attr('stroke-width', 2);

                g.selectAll('circle.point')
                    .data(points)
                    .join('circle')
                    .attr('class', 'point')
                    .attr('cx', d => x(d.a))
                    .attr('cy', d => y(d.b))
                    .attr('r', d => radiusScale(d.minExpr))
                    .attr('fill', d => colorScale(d.foldChange))
                    .attr('fill-opacity', 0.7)
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 0.5)
                    .on('mouseover', function(event, d) {
                        showTooltip(event, `
                            <strong>${d.gene}</strong><br>
                            ${state.classA}: ${d.a.toFixed(3)}<br>
                            ${state.classB}: ${d.b.toFixed(3)}<br>
                            Fold Change: ${d.foldChange.toFixed(2)}x
                        `);
                    })
                    .on('mouseout', hideTooltip);

                g.append('g')
                    .attr('transform', `translate(0,${innerH})`)
                    .call(d3.axisBottom(x));

                g.append('g').call(d3.axisLeft(y));

                g.append('text')
                    .attr('x', innerW / 2)
                    .attr('y', innerH + 45)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text(`${state.classA} Expression`);

                g.append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('x', -innerH / 2)
                    .attr('y', -40)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text(`${state.classB} Expression`);

                // Add colorbar for fold change
                const colorbarWidth = 25;
                const colorbarHeight = Math.min(innerH * 0.8, 250);
                const colorbarY = (innerH - colorbarHeight) / 2;
                const maxFoldChange = d3.max(points, d => d.foldChange) || 1;

                const colorbar = svg.append('g')
                    .attr('transform', `translate(${width - margin.right + 15}, ${margin.top + colorbarY})`);

                const colorbarScale = d3.scaleLinear()
                    .domain([0, maxFoldChange])
                    .range([colorbarHeight, 0]);

                const colorbarAxis = d3.axisRight(colorbarScale)
                    .ticks(6)
                    .tickSize(6)
                    .tickFormat(d3.format('.1f'));

                // Create colorbar gradient
                const gradient = svg.append('defs')
                    .append('linearGradient')
                    .attr('id', 'pairwise-colorbar-gradient')
                    .attr('gradientUnits', 'userSpaceOnUse')
                    .attr('x1', 0).attr('y1', colorbarHeight)
                    .attr('x2', 0).attr('y2', 0);

                const numStops = 50;
                for (let i = 0; i <= numStops; i++) {
                    const value = (i / numStops) * maxFoldChange;
                    gradient.append('stop')
                        .attr('offset', `${(i / numStops) * 100}%`)
                        .attr('stop-color', colorScale(value));
                }

                // Add title above colorbar
                colorbar.append('text')
                    .attr('x', colorbarWidth / 2)
                    .attr('y', -15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', '600')
                    .style('fill', '#333')
                    .text('Fold Change');

                colorbar.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', colorbarWidth)
                    .attr('height', colorbarHeight)
                    .style('fill', 'url(#pairwise-colorbar-gradient)')
                    .attr('stroke', '#666')
                    .attr('stroke-width', 1);

                // Add tick marks and labels
                const axisGroup = colorbar.append('g')
                    .attr('transform', `translate(${colorbarWidth}, 0)`)
                    .call(colorbarAxis);

                // Style the axis
                axisGroup.selectAll('path, line')
                    .style('stroke', '#666')
                    .style('stroke-width', 1);

                axisGroup.selectAll('text')
                    .style('font-size', '11px')
                    .style('fill', '#333');

                // Add tick marks on the left side of the colorbar for better visibility
                const leftTicks = colorbar.append('g');
                const tickValues = colorbarScale.ticks(6);

                leftTicks.selectAll('line')
                    .data(tickValues)
                    .join('line')
                    .attr('x1', -3)
                    .attr('x2', 0)
                    .attr('y1', d => colorbarScale(d))
                    .attr('y2', d => colorbarScale(d))
                    .style('stroke', '#666')
                    .style('stroke-width', 1);

                // Add checkbox for axis scaling toggle - positioned above chart area, below title
                const checkboxGroup = svg.append('g')
                    .attr('transform', `translate(${margin.left + 10}, ${margin.top - 10})`);

                // Background for checkbox area
                checkboxGroup.append('rect')
                    .attr('x', -8)
                    .attr('y', -18)
                    .attr('width', 130)
                    .attr('height', 22)
                    .attr('fill', 'rgba(255, 255, 255, 0.95)')
                    .attr('stroke', '#ccc')
                    .attr('stroke-width', 1)
                    .attr('rx', 4);

                // Modern checkbox circle
                const checkbox = checkboxGroup.append('circle')
                    .attr('cx', 7)
                    .attr('cy', -7)
                    .attr('r', 6)
                    .attr('fill', state.symmetricAxes ? '#667eea' : 'white')
                    .attr('stroke', '#667eea')
                    .attr('stroke-width', 2)
                    .style('cursor', 'pointer');

                // Inner dot for checked state
                if (state.symmetricAxes) {
                    checkboxGroup.append('circle')
                        .attr('cx', 7)
                        .attr('cy', -7)
                        .attr('r', 3)
                        .attr('fill', 'white')
                        .style('pointer-events', 'none');
                }

                // Label
                checkboxGroup.append('text')
                    .attr('x', 18)
                    .attr('y', -3)
                    .style('font-size', '11px')
                    .style('fill', '#333')
                    .style('font-weight', '500')
                    .style('pointer-events', 'none')
                    .text('Symmetric axes');

                // Click handler
                checkboxGroup
                    .style('cursor', 'pointer')
                    .on('click', function() {
                        state.symmetricAxes = !state.symmetricAxes;
                        renderPairwise();
                    });
            }

            function renderDiscriminators() {
                const container = elements.discriminators;
                clearChart(container);

                if (!state.df || !state.classA || !state.classB) return;

                const width = container.clientWidth || 600;
                const height = container.clientHeight || 420;

                // Calculate discrimination scores first to determine top genes and dynamic margin
                const scores = discriminationScores(state.classA, state.classB, state.minExpr);
                const indices = d3.range(scores.length);
                indices.sort((a, b) => scores[b] - scores[a]);
                const topIndices = indices.slice(0, 20);
                const geneNames = topIndices.map(i => state.genes[i]);
                const maxGeneNameLength = Math.max(...geneNames.map(name => name.length));
                const dynamicLeftMargin = Math.max(80, Math.min(maxGeneNameLength * 8, 200));

                const margin = { top: 20, right: 20, bottom: 40, left: dynamicLeftMargin };
                const innerW = width - margin.left - margin.right;
                const innerH = height - margin.top - margin.bottom;

                const data = topIndices.map(i => {
                    const exprA = +state.df[i][state.classA] || 0;
                    const exprB = +state.df[i][state.classB] || 0;
                    const foldChange = Math.abs(Math.max(exprA, 1e-6) / Math.max(exprB, 1e-6));
                    return {
                        gene: state.genes[i],
                        score: scores[i],
                        exprA: exprA,
                        exprB: exprB,
                        foldChange: foldChange
                    };
                });

                const y = d3.scaleBand()
                    .domain(data.map(d => d.gene))
                    .range([0, innerH])
                    .padding(0.1);

                const x = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.score) || 1])
                    .nice()
                    .range([0, innerW]);

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                g.selectAll('rect.bar')
                    .data(data)
                    .join('rect')
                    .attr('class', 'bar')
                    .attr('x', 0)
                    .attr('y', d => y(d.gene))
                    .attr('width', d => x(d.score))
                    .attr('height', y.bandwidth())
                    .attr('fill', '#60a5fa')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1)
                    .on('mouseover', function(event, d) {
                        showTooltip(event, `
                            <strong>${d.gene}</strong><br>
                            Discrimination Score: ${d.score.toFixed(3)}<br>
                            ${state.classA}: ${d.exprA.toFixed(3)}<br>
                            ${state.classB}: ${d.exprB.toFixed(3)}<br>
                            Fold Change: ${d.foldChange.toFixed(2)}x
                        `);
                    })
                    .on('mouseout', hideTooltip);

                g.append('g').call(d3.axisLeft(y));
                g.append('g')
                    .attr('transform', `translate(0,${innerH})`)
                    .call(d3.axisBottom(x));

                g.append('text')
                    .attr('x', innerW / 2)
                    .attr('y', innerH + 35)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text('Discrimination Score');
            }

            function updateChartTitles() {
                if (state.classA && state.classB) {
                    elements.specificityTitle.textContent = `Most Specific Genes for ${state.classA}`;
                    elements.pairwiseTitle.textContent = `${state.classA} vs ${state.classB} Gene Counts`;
                    elements.discriminatorsTitle.textContent = `Top Discriminating Genes ${state.classA} vs ${state.classB}`;
                } else {
                    elements.specificityTitle.textContent = 'Gene Specificity Analysis';
                    elements.pairwiseTitle.textContent = 'Pairwise Class Comparison';
                    elements.discriminatorsTitle.textContent = 'Top Discriminating Genes';
                }
            }

            function renderAllCharts() {
                if (!state.df || !state.classA || !state.classB) return;

                clearError();
                updateChartTitles();
                try {
                    renderHeatmap();
                    renderSpecificity();
                    renderPairwise();
                    renderDiscriminators();
                } catch (error) {
                    console.error('Rendering error:', error);
                    showError(`Rendering error: ${error.message}`);
                }
            }

            // Event listeners
            elements.file.addEventListener('change', async (e) => {
                const file = e.target.files && e.target.files[0];
                if (!file) return;

                showStatus('Reading CSV file...', 0);
                try {
                    const text = await file.text();
                    await handleCSVText(text);

                    // Update file input label
                    const label = elements.file.nextElementSibling;
                    label.textContent = `üìÅ ${file.name}`;
                } catch (error) {
                    showError(`Error reading file: ${error.message}`);
                    showStatus('');
                }
            });

            elements.classA.addEventListener('change', () => {
                state.classA = elements.classA.value;
                renderAllCharts();
            });

            elements.classB.addEventListener('change', () => {
                state.classB = elements.classB.value;
                renderAllCharts();
            });

            elements.minExpr.addEventListener('input', () => {
                state.minExpr = +elements.minExpr.value;
                elements.minExprVal.textContent = state.minExpr.toFixed(2);
                renderAllCharts();
            });

            // Window resize handler
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(renderAllCharts, 250);
            });

            // Initialize
            showStatus('Ready - Upload a CSV file to begin analysis');
        })();
    </script>
</body>
</html>